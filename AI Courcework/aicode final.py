import random
import math
#optimizing heat exchanger design with respect to three variables:
#shell diameter Ds, outside diameter of tubes Do, and baffle spacing B
def foo(Ds, Do, B) :
    #energy cost (pounds per kWh)
    Ce = 0.12
    #annual operating time (h)
    H = 7000
    #tube side mass flow rate (kg/s)
    mt = 35.31
    #tube side fluid density (kg/m^3)
    rhot = 999
    #shell side fluid density (kg/m^3)
    rhos = 995
    #shell side mass flow rate (kg/s)
    ms = 22.07
    #shell side fluid specific heat capacity (kJ/kg-K)
    cps = 4.18
    #shell side fluid temperature change (K)
    delTs = 4.5
    #overall heat transfer coefficient (W/m^2-K)
    U = 1296
    #log mean temperature difference (LMTD) (K)
    delTm = 6.31
    #LMTD correction factor
    F = 1
    #tube side fluid viscosity (Pa s)
    mut = 0.00092
    #shell side fluid viscosity (Pa s)
    mus = 0.0008
    #internal diameter of tubes (m)
    Di = 0.8 * Do
    #tube pitch (m)
    Pt = 1.25 * Do
    #number of tube passes
    n = 2
    #number of tubes
    Nt = 0.156 * math.pow((Ds/Do), 2.291)
    #equivalent shell diameter (m)
    De = 4 * (math.pow(Pt,2)-3.14 * math.pow(Do,2)/4)/(3.14 * Do)
    #shell side Reynold's number
    Res = 4 * ms/(3.14 * Ds * mus)
    #tube side Reynold's number
    Ret = 4 * mt/(3.14 * Di * mut)
    #shell side fluid velocity (m/S)
    vs = ms * Pt/(rhos * Ds * B * (Pt-Do))
    #shell side fluid velocity (m/s)
    vt = 4 * mt * n/(3.14 * math.pow(Do,2) * rhot * Nt)
    #shell side friction factor
    fs = 1.44 * math.pow(Res,-0.15)
    #tube side friction factor
    ft = math.pow(1.82*math.log10(Ret)-1.64,-2)
    #heat duty (kW)
    Q = ms*cps*delTs
    #heat exchange surface area (m^2)
    S = Q/(U*delTm*F)
    #tube length (m)
    L = S/(3.14 * Do *Nt)
    #annual operating cost (pounds per year)
    Co = Ce*H * (mt*math.pow(vt,2)*n *(L*ft/Di + 2.5) + ms *math.pow(vs,2)*fs*L*Ds/B/De)/2
    #annual discount rate (%)
    i = 0.1
    #lifetime of heat exchanger (years)
    ny = 10
    sum = 0
    #for loop to find total discounted operating cost in pounds
    for k in range(1,ny):
        sum += Co/math.pow(1+i,k)
    
    return sum

    # return Ce * H * (mt*(8*mt/(0.249 * 3.14 * rhot * Do **2 * (Ds/Do)**2.207  ))**2 * ((ms * cps * delTs/(0.1992 * 3.14 * U * delTm * F * Do**2 *((Ds/Do)**2.207)) )* (1.82 * math.log10(5* mt/(3.14 * Do * mut))-1.64)**-2 + 2.5)+(0.18*ms/B) * (5*ms/(rhos * Ds * B))**2 * (4 * ms/(3.14*Ds * mus))**-0.15 * (ms * cps * delTs / (0.249 * 3.14 * U *delTm * F * Do * (Ds/Do)**2.207))*(3.14*Ds/(0.777 * Do)))

def fitness(Ds, Do, B) :
    ans = foo(Ds, Do, B)
    #this is the fitness function used here
    if ans == 0:
        return 99999
    else:
        return abs(1/ans)
    
#generate solutions
solutions = []
#the solutions list contains the possible solutions
for s in range (1000):
    Ds = random.uniform(0.1, 1.5)
    #This randomly selects a value with Ds's range of 0.1 to 1.5
    Do = random.uniform(0.015, 0.051)
    #This randomly selects a value with Do's range of 0.015 to 0.051
    B = random.uniform(0.05, 0.5)
    #This randomly selects a value with B's range of 0.05 to 0.5
    # check if values are within range
    if 0.1 <= Ds <= 1.5 and 0.015 <= Do <= 0.051 and 0.05 <= B <= 0.5:\
    #This bit ensures that the assigned values never leave the assigned range
        solutions.append((Ds, Do, B))
    else:
        # regenerate solution if any value is out of range
        s -= 1

for i in range (10000):

    rankedsolutions = []
    
    #The ranked solutions takes the random values generated by the solutions and applies it to the fitness function
    for s in solutions:
        rankedsolutions.append( (fitness(s[0],s[1],s[2]),s,foo(s[0],s[1],s[2])) ) 
    rankedsolutions.sort()
    #this sorts them with the fitness function values from lowest to greatest
    rankedsolutions.reverse()
    #this reverses it as we want the solution with the lowest fitness value
    
    print(f"=== Gen{i} bestsolutions ===")
    #this prints the best solution in each gen
   
    print(rankedsolutions[0])
  

    if rankedsolutions[0][0] > 999999:
    # if i == 100:
        break

    if i == 100:
        break

    bestsolutions = rankedsolutions[:100]
    # bestsolutions.reverse()

    elements = []
    for s in bestsolutions:
        elements.append(s[1][0])
        #crossover occurs here.Here, the top-performing solutions (bestsolutions) are selected, and their elements are added to the "elements" list.

        elements_2 = []
    for s in bestsolutions:
        elements_2.append(s[1][1])

        elements_3 = []
    for s in bestsolutions:
        elements_3.append(s[1][2])
         
    newGen = []
    for s in range(1000):
        e1 = random.choice(elements) * random.uniform(0.99,1.01)   
        #mutation occurs here.a random element from the selected best solutions is chosen and then multiplied by a 
        # small random value between 0.99 and 1.01 to introduce some small variations (mutation) in the selected elements,
        #  which creates new solutions for the next generation
        e2 = random.choice(elements_2) * random.uniform(0.99,1.01)
        e3 = random.choice(elements_3) * random.uniform(0.99,1.01)
        if 0.5<= e1 <= 1.5 and 0.015 <= e2 <= 0.051 and 0.05 <= e3 <= 0.5:
         newGen.append((e1,e2,e3))
        else:
        # regenerate solution if any value is out of range
         s -= 1

        

    solutions = newGen
    #assigns the newly generated solutions to the next generation